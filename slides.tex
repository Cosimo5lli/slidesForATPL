%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% I, the copyright holder of this work, release this work into the
%% public domain. This applies worldwide. In some countries this may
%% not be legally possible; if so: I grant anyone the right to use
%% this work for any purpose, without any conditions, unless such
%% conditions are required by law.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows}
\usetheme[faculty=fi,logoPath=logo/,logo=logo/LOGO.pdf]{fibeamer}
\usepackage[
main=english, %% By using `czech` or `slovak` as the main locale
%% instead of `english`, you can typeset the
%% presentation in either Czech or Slovak,
%% respectively.
italian %% The additional keys allow foreign texts to be
]{babel}        %% typeset as follows:
%%
%%   \begin{otherlanguage}{czech}   ... \end{otherlanguage}
%%   \begin{otherlanguage}{slovak}  ... \end{otherlanguage}
%%
%% These macros specify information about the presentation
\title{An extension of FJ to interfaces and intersection types} %% that will be typeset on the
\subtitle{Syntax, typing, subtyping and evaluation rules} %% title page.
\author{Cosimo Cinquilli \& Gabriele Giannini}
%% These additional packages are used within the document:
\usepackage{ragged2e}  % `\justifying` text
\usepackage{booktabs}  % Tables
\usepackage{tabularx}
\usepackage{tikz}      % Diagrams
\usetikzlibrary{calc, shapes, backgrounds}
\usepackage{amsmath, amssymb}
\usepackage{url}       % `\url`s
\usepackage{listings}  % Code listings

\usepackage{mathtools}
\usepackage{xargs}
\usepackage{esvect}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
	language=Java,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=3
}

\newcommand{\syntaxtag}[1]{{\textit{#1}}}
\newcommand{\syntaxkeyword}[1]{\texttt{#1}}
\newcommand{\aargs}[1]{\vv #1}

% un bello spazio verticale per evitare che le cose nelle frazioni siano appiccicate fra loro
\newcommand{\hs}{\vphantom{\tilde{\aargs{I}}}}

% la class declaration
\newcommand{\iclass}[3]{\syntaxkeyword{class } #1 \syntaxkeyword{ extends } #2 \syntaxkeyword{ implements } \aargs #3 \; \{ \aargs T \, \aargs f ; \; K \; \aargs M \} \hs}
% l'interface declaration
\newcommandx{\einterface}[2][2=I]{\syntaxkeyword{interface } #1 \syntaxkeyword{ extends } \aargs #2 \;\{ \aargs S\} \hs }
% \newcommand{\mathlarge}[1]{\mbox{\LARGE $#1$}}
\newcommand{\mathlarge}[1]{\displaystyle {#1}}
\newcommand{\onto}[1]{\atop \mathlarge{#1}}
\newcommand{\sig}{\Sigma ig}


\frenchspacing
\begin{document}
	\frame{\maketitle}
	
	\AtBeginSection[]{% Print an outline at the beginning of sections
		\begin{frame}<beamer>
		\frametitle{Outline for Section \thesection}
		\tableofcontents[currentsection]
\end{frame}}


\section{Extending FJ to interfaces: FIJ}

\begin{frame}
\frametitle{Extending FJ to interfaces: FIJ}
\framesubtitle{The final objective}
We wanto to introduce interfaces in FJ in order to be able to have a more
sophisticated structure of the types relation (no more a simple tree).

We want obviously to maintain the core functionality that we have already, just adding interfaces
on top of that. Moreover, we want to rest sure that every FIJ program is indeed a valid Java
program, as it was the case for FJ.
\end{frame}

\begin{frame}
\frametitle{Simbols and their meanings}
\framesubtitle{Let's get the notation clear}
\begin{columns}[onlytextwidth]
\column{.5\textwidth}
$I, J$ = interface names\\[5pt]
$C, D$ = class names\\[5pt]
$T, U, V$ = types literals\\[5pt]
$\aargs S, \Sigma, S, Z$ = sets of signatures\\[5pt]
$\aargs M$ = methods declarations\\[5pt]
% $K$ = constructor\\
$\aargs f, \aargs g$ = fields\\[5pt]
$\aargs x$ = formal parameters\\
\column{.5\textwidth}
$\aargs a$ = \parbox{.6\textwidth}{generic list or set of elements as $a$}
% \begin{flalign*} % allineato alla prima riga
%   \aargs{I} = \; I_1,&\dots,I_n \;\; or\\
%   I_1\&&\dots\&I_n
% \end{flalign*}
\begin{flalign*} % centrato verticalmente
&\aargs{I} = {\hspace{15pt} I_1,\dots,I_n \;\; or\atop{
		I_1\&\dots\&I_n}}&
\parbox{40pt}{\scriptsize{(specific for\\ interfaces)}}
\end{flalign*}\\
$T \in \aargs T \Leftrightarrow \aargs T = T_1,\dots,T,\dots,T_n$\\[5pt]
$T<:\aargs U \Leftrightarrow T<:U \;\;\; \forall U \in \aargs U$\\[5pt]
$\aargs T = \aargs U \Leftrightarrow T_i = U_i \;\,for\ 1\leq i\leq n$
\end{columns}
\end{frame}

\subsection{Extending the syntax}
\begin{frame}{The new syntax (1/3)}
\framesubtitle{Classes, interfaces, method signatures}
\vspace{-10pt}
\begin{flalign*}
IN &::= \hspace{175pt}\syntaxtag{interface declaration}&\\
&\qquad \einterface{I} &\\[10pt]
S &::= \hspace{136pt}\syntaxtag{method signature declaration}&\\
&\qquad T \; m(\aargs T \ \aargs x);&\\[10pt]
CL &::= \hspace{193pt}\syntaxtag{class declaration}&\\
&\qquad \iclass{C}{C}{I}&\\
\end{flalign*}
\end{frame}

\begin{frame}{The new syntax (2/3)}
\framesubtitle{Constructor, methods, types}
\begin{flalign*}
K &::= \hspace{165pt}\syntaxtag{constructor declaration}&\\
&\qquad C(\aargs T \ \aargs f\,) \ \{\,\syntaxkeyword{super}(\aargs f\,); \; \syntaxkeyword{this}.\aargs f = \aargs f;\,\}&\\[10pt]
M &::= \hspace{138pt}\syntaxtag{complete method declaration}&\\
&\qquad T \; m(\aargs T \ \aargs x) \ \{\,\syntaxkeyword{return } t;\,\}&\\[10pt]
T &::= \hspace{220pt}\syntaxtag{type literal}&\\
&\qquad C \; | \; I &\\
\end{flalign*}
\end{frame}

\begin{frame}{The new syntax (3/3)}
\framesubtitle{Terms, values}
\vspace{-10pt}
\begin{flalign*}
t &::= &\syntaxtag{terms:}\\
&\qquad x &\syntaxtag{variables}\\
&\qquad t.f &\syntaxtag{field access}\\
&\qquad t.m(\aargs t) &\syntaxtag{method invocation}\\
&\qquad \syntaxkeyword{new } C(\aargs t) &\syntaxtag{object creation}\\
&\qquad (T) \ t &\syntaxtag{cast}\\[10pt]
v &::= &\syntaxtag{values:}\\
&\qquad \syntaxkeyword{new } C(\aargs v) &\syntaxtag{object creation}
\end{flalign*}
\end{frame}

\subsection{Extending the subtype relation}
\begin{frame}
\frametitle{Extending the definition of the subtype relation}

\begin{definition}
\vspace{-25pt}
\begin{flalign*}
&T<:T &\\[5pt]
&\dfrac{T<:U \qquad U<:V}{T<:V} &\\
&\dfrac{\mathlarge{CT(C) = \iclass{C}{D}{I}}}{C<:D \quad C<:\aargs I} &\\
&\dfrac{CT(I) = \einterface{I}[J]}{I<: \aargs{J}} &
% &\dfrac{CT(C) = \iclass{C}{D}{I}}{C<:\aargs{I}} &
\end{flalign*}
\end{definition}
\end{frame}

\subsection{Auxiliary functions}

\begin{frame}{Preparing for extension}
\boldmath
% \framesubtitle{Adding some auxiliary functions}
We add the $IObject$ type: as $Object$ is the supertype of every class,
so $IObject$ is an empty interface outside the Class Table that is the
supertype of every interface.

We then define a new function $\sig$ on classes and groups of interfaces, we define also a new
predicate $is\sig ok$ on sets of signatures and we redefine $mtype$ also for interfaces.
\end{frame}

\subsubsection{$is\sig ok$ predicate}
\begin{frame}
\frametitle{$is\sig ok$ predicate}
\framesubtitle{Defined on a set of signatures}
This helper predicate is $true$ if and only if the set of signatures is actually an interface,
that is, for any method name in it, it contains \alert{only one} signature for that name.
\begin{definition}
\vspace{-20pt}
\begin{flalign*}
&\dfrac{
T\ m(\aargs T\ \aargs x);\in\Sigma \land U\ m(\aargs U\ \aargs{y});\in\Sigma
\;\;\alert{\text{ implies }}\;\; T=U \land \aargs{T}=\aargs{U}
}{is\sig ok(\Sigma)}
\end{flalign*}
\end{definition}
\end{frame}

\subsubsection{$\sig$ function}

\begin{frame}{$\sig$ function}
\framesubtitle{For interfaces and groups of interfaces}
\begin{definition}
\vspace{-20pt}
\begin{flalign*}
&\sig(IObject)=\emptyset &\\[10pt]
% &\dfrac{\mathlarge{
%     CT(I)=\einterface{I}[J] \atop
%     \sig(\aargs{J}) = \aargs{S}
% }}{\sig(I) = \aargs{S} \cup \aargs{N} \hs} &\\[10pt]
% &\dfrac{\mathlarge{
%     I \in \aargs{I} \quad \sig(I) = \aargs S \quad \sig(\aargs I \setminus \{I\}) = \aargs R
% }}{\sig(\aargs I) = \aargs S \cup \aargs R}
&\dfrac{
\mathlarge{
CT(I) = \einterface{I}[J] \atop
% \Sigma = \sig(J_1)\cup\dots\cup\sig(J_n)\cup\aargs N
\Sigma = \sig(J_1,\dots, J_n)
}
}{\sig(I) = \Sigma \cup\aargs S}&\\[10pt]
&\dfrac{
\mathlarge{
\Sigma = \sig(I_1)\cup\dots\cup\sig(I_n)
% \qquad is\sig ok(\Sigma)
}
}{\sig(I_1, \dots, I_n) = \Sigma}&
\end{flalign*}
\end{definition}
\end{frame}

\begin{frame}{$\sig$ function}
\framesubtitle{For classes}
\begin{definition}
\vspace{-20pt}
\begin{flalign*}
&\sig(Object) = \emptyset &\\[5pt]
&\dfrac{\mathlarge{
CT(C) = \iclass{C}{D}{I}
\onto{ \Sigma = \bigl\{ T \;\; m(\aargs T \ \aargs x); \; \big| \; T \;\; m(\aargs T \ \aargs x) \{\syntaxkeyword{return } t;\} \in \aargs{M} \bigr\}
\onto{\sig(D) = S}
% \qquad \sig(\aargs I) = Z
}
}}{\sig(C)=\Sigma \cup S \hs}&
\end{flalign*}
\end{definition}
% \scriptsize{
% \begin{alertblock}{Note}
%   We include the signatures of the implemented interfaces. This will be useful later when
%   dealing with the typing of classes.
% \end{alertblock}}
\end{frame}

\subsubsection{mtype function}
\begin{frame}
\frametitle{mtype function}
% \framesubtitle{For interfaces}
\begin{definition}
\vspace{-20pt}
\begin{flalign*}
% &\dfrac{
%   CT(I) = \einterface{I} \quad T \ m(\aargs T \ \aargs x); \in \aargs S
% }
% {mtype(m,I) = \aargs T \rightarrow T \hs} &\\[10pt]
% &\dfrac{
%   \mathlarge{ % \mathlarge per evitare che le cose scritte sotto \atop vengano piccoline
%     CT(I) = \einterface{I}
%     \atop m \text{ is not in declared in } I \qquad T\ m(\aargs T\ \aargs x); \in \sig(\aargs I)
%   }
% }
% {mtype(m,I) = \aargs T \rightarrow T}
% &&\syntaxtag{(for interfaces)}\\[-25pt]
% &\dfrac{
%     T\ m(\aargs T\ \aargs x);\, \in\, \sig(I)
% }
% {mtype(m,I) = \aargs T \rightarrow T}&\\[10pt]
% &&\syntaxtag{(for classes)}\\[-22pt]
% &\dfrac{
%   T\ m(\aargs T\ \aargs x);\,\in\,\sig(C)
% }{mtype(m, C)=\aargs T \rightarrow T}
&\dfrac{
U\ m(\aargs U\ \aargs x);\,\in\,\sig(T)
}{mtype(m, T)=\aargs U \rightarrow U}
% \\[5pt]
% &\dfrac{
%   % \mathlarge
%   {
%     CT(C)=\iclass{C}{D}{I} \atop
%     T\ m(\aargs T\ \aargs x);\,\{\syntaxkeyword{return }t;\} \in\, \aargs M
%   }
% }{mtype(m,C) = \aargs T \rightarrow T}&
\end{flalign*}
\end{definition}
\small{
\begin{alertblock}{Note}
\boldmath
The $\sig$ function greatly simplify the definition of $mtype$.\\
% Please, also note that with this definition if a class $C$ doesn't implement a method body for $m$,
% a method declared in an implemented interface, $mtype(m,C)$ will still be defined, returning
% the expected type for the method. This is not a problem, we will see that we can use $mbody$ to correctly
% check this.
%
Also note that, as was the case in FJ, $mtype(m,C)$ is not defined if the method $m$ is not implemented
in $C$ or any of its superclasses.
\end{alertblock}
}
\end{frame}

% \subsubsection{$mbody$ function}

\begin{frame}{$mbody$ function}
\framesubtitle{Just a recall of the definition}
\begin{definition}
\vspace{-20pt}
\begin{flalign*}
&\dfrac{
\mathlarge{
CT(I) = \iclass{C}{D}{I} \atop
T\ m(\aargs T\ \aargs x)\; \{\syntaxkeyword{return }t;\}\,\in\aargs M
}
}{mbody(m,C) = (\aargs x, t)}&\\[10pt]
&\dfrac{
\mathlarge{
CT(C)=\iclass{C}{D}{I}
\atop m\text{ is not defined in }\aargs M
}
}{mbody(m,C) = mbody(m,D)}&
\end{flalign*}
\end{definition}
\end{frame}

% \begin{frame}
%   \frametitle{mtype function}
%   \framesubtitle{For classes}
%   \begin{definition}
%     \vspace{-20pt}
%     \begin{flalign*}
%       &\dfrac{
%         \mathlarge{ % \mathlarge per evitare che le cose scritte sotto \atop vengano piccoline
%           CT(C) = \iclass{C}{D}{I}
%           \atop C \ m(\aargs C \ \aargs x); \in \aargs N
%         }
%       }
%       {
%         mtype(m,C) = \aargs C \rightarrow C \hs} &\\[10pt] %a capo di 10 punti per fare spazio
%       &\dfrac{
%         \mathlarge{
%           CT(C) = \iclass{C}{D}{I}
%           \atop m \text{ is not in declared in } I \hs
%         }
%       }
%       {mtype(m,C) = mtype(m,D)}
%   \end{flalign*}
%   \end{definition}
% \end{frame}

% \begin{frame}
%   \frametitle{names function}
%   % \framesubtitle{}
%   Really small function, but it let us define the next predicate, $compatible$, in a more
%   compact and readable way.
%   \begin{definition}
%     \vspace{-20pt}
%     \begin{flalign*}
%       &\dfrac{
%         \mathlarge{ % \mathlarge per evitare che le cose scritte sotto \atop vengano piccoline
%           P = \{m\; \big| \; T\; m(\aargs T \ \aargs x); \in signatures(\aargs I)\}
%         }
%       }
%       {names(\aargs I) = P}
%   \end{flalign*}
%   \end{definition}
% \end{frame}

% \subsubsection{compatible predicate}
% \begin{frame}
%   \frametitle{compatible predicate}
%   \framesubtitle{Defined on groups of interfaces}
%   \vspace{-5pt}
%   \begin{definition}
%     \vspace{-30pt}
%     \begin{flalign*}
%       % &\dfrac{
%       %   \mathlarge{
%       %     I \in \aargs I \qquad \aargs J = \aargs I \setminus \{I\} \qquad compatible(\aargs{J})
%       %     \onto{
%       %       (T\; m(\aargs{T}\ \aargs x); \in signatures(\aargs J) \text{ implies } mtype(m, I) \text{ not defined}
%       %       \onto{
%       %         \text{or } T\; m(\aargs T\ \aargs x); \in signatures(\aargs J) \land mtype(m, I) = \aargs T \rightarrow T)
%       %       }
%       %     }
%       %   }
%       % }
%       % &\dfrac{
%       %   \mathlarge{
%       %     I \in \aargs I \qquad \aargs J = \aargs I \setminus \{I\} \qquad compatible(\aargs{J})
%       %     \onto{ P = \{m\; \big| \; T\; m(\aargs T \ \aargs x); \in signatures(\aargs I)\} \qquad m\in P
%       %       \onto{
%       %         (mtype(m,\aargs J)=\aargs U \rightarrow U \text{ implies } mtype(m, I) \text{ not defined}
%       %         \onto{
%       %           \text{or } mtype(m,\aargs J)=\aargs U \rightarrow U \land mtype(m, I) = \aargs U \rightarrow U)
%       %         }
%       %       }
%       %     }
%       %   }
%       % }
%       &\dfrac{}{compatible(I)}\\[10pt]
%       &\dfrac{
%         \mathlarge{
%           I \in \aargs I \qquad \aargs J = \aargs I \setminus \{I\} \qquad compatible(\aargs{J}) \qquad m\in names(\aargs I)
%             \onto{
%               mtype(m,\aargs J)=\aargs U \rightarrow U \;\; \alert{\text{implies}}\;\; mtype(m, I) \;\;\alert{\text{not defined}}
%             }
%         }
%       }
%       {compatible(\aargs I) \hs}\\[10pt]
%       &\dfrac{
%         \mathlarge{
%           I \in \aargs I \qquad \aargs J = \aargs I \setminus \{I\} \qquad compatible(\aargs{J}) \qquad m\in names(\aargs I)
%             \onto{
%                 mtype(m,\aargs J)=\aargs U \rightarrow U \qquad mtype(m, I) = \aargs U \rightarrow U \hs
%             }
%         }
%       }
%       {compatible(\aargs I) \hs}
%     \end{flalign*}
%   \end{definition}
% \end{frame}

\subsection{Extending the typing rules}

\begin{frame}
\frametitle{The new typing rules}
\vspace{-30pt}
\begin{flalign*}
&&\syntaxtag{(T-VAR)} \\[-20pt]
&\dfrac{ x:T \in \Gamma }{ \Gamma \vdash x:T } &\\[10pt]
&&\syntaxtag{(T-FIELD)} \\[-20pt]
&\dfrac{ \Gamma \vdash t_0 : C_0 \qquad fields(C_0) = \aargs T \; \aargs f}
{\Gamma \vdash t_0 . f_i : T_i }&\\[10pt]
&&\syntaxtag{(T-UCAST)} \\[-20pt]
&\dfrac{ \Gamma \vdash t_0 : U \qquad U <: T}
{ \Gamma \vdash (T)\, t_0 : T} &\\[10pt]
&&\syntaxtag{(T-DCAST)} \\[-20pt]
&\dfrac{ \Gamma \vdash t_0:U \qquad T <: U \qquad T \neq U}
{ \Gamma \vdash (T)\, t_0:T}
\end{flalign*}
\end{frame}

\begin{frame}
\frametitle{The new typing rules}
\vspace{-30pt}
\begin{flalign*}
&&\syntaxtag{(T-INVK)} \\[-20pt]
&\dfrac{
\mathlarge{
\Gamma \vdash t_0:C_0 \qquad mtype(m, C_0) = \aargs U \rightarrow T
\atop
\Gamma \vdash \aargs t:\aargs T \qquad \aargs T <: \aargs U \hs
}
}{ \Gamma \vdash t_0.m(\aargs t): T \hs} &\\[10pt]
&&\syntaxtag{(T-NEW)} \\[-20pt]
&\dfrac{
\mathlarge{
fields(C) = \aargs U \ \aargs f \atop
\Gamma \vdash \aargs t:\aargs T \qquad \aargs T <: \aargs U \hs
}
}{\Gamma \vdash \syntaxkeyword{new }C(\aargs t):C \hs}&\\[10pt]
\end{flalign*}
\end{frame}

\begin{frame}
\frametitle{The new typing rules}
\vspace{-30pt}
\begin{flalign*}
&&\syntaxtag{(m OK in C)} \\[-20pt]
&\dfrac{
\mathlarge{
\aargs x: \aargs T, \syntaxkeyword{this}:C \vdash t_0:U \qquad U<:T
\atop {
% CT(C)=\iclass{C}{D}{I}
% \onto{
% \sig(C) = \Sigma \qquad is\sig ok(\Sigma)
T\ m(\aargs T\ \aargs x);\,\in\,\sig(C)
% }
}
}
}{
T \  m(\aargs T \aargs x)\; \{ \syntaxkeyword{return } t_0;\} \text{ OK in C}
}\\[20pt]
&&\syntaxtag{(C OK for I)} \\[-20pt]
&\dfrac{
\mathlarge{
T \; m(\aargs T \aargs x); \in \sig(I) \qquad mbody(m,C)=(\aargs x,t_0)
\atop
mtype(m, C) = \aargs T \rightarrow U \qquad U = T \hs
}
}{ C\text{ OK for }I} \hspace{-300pt} &\\[20pt]
&&\syntaxtag{alternative (C OK for I)} \\[-20pt]
&\dfrac{
\sig(I) \subseteq \sig(C)
}{ C\text{ OK for }I} &\\
\end{flalign*}
\end{frame}

\begin{frame}
\frametitle{The new typing rules}
\begin{flalign*}
&&\syntaxtag{(C OK)} \\[-20pt]
&\dfrac{
\mathlarge{
K  =  C(\aargs U \ \aargs g, \aargs T \ \aargs f)\ \{\syntaxkeyword{super}(\aargs g ); \; \syntaxkeyword{this}.\aargs f = \aargs f;\}
\onto{
fields(D)=\aargs U\ \aargs g \qquad \aargs M \text{ OK IN } C \hs
\onto{
\Sigma=\sig(C)\cup\sig(\aargs I) \qquad is\sig ok(\Sigma) \qquad C \text{ OK FOR } \aargs I
}
}
}
}{\small{\iclass{C}{D}{I} \text{ OK}}}&\\[20pt]
% &&\syntaxtag{(m OK in I)}\\[-20pt]
% &\dfrac{
%   \mathlarge{
%     \small{CT(I) = \einterface{I}} \qquad J\in \aargs I \atop
%     override(m,J,\aargs T, T)
%   }
% }{T \ m(\aargs T \ \aargs x); \enspace \text{OK in } I } &\\[10pt]
&&\syntaxtag{(I OK)} \\[-20pt]
&\dfrac{\sig(I)=\Sigma \qquad is\sig ok(\Sigma)
% \qquad \aargs S \text{ OK in }I
}
{\einterface{I} \enspace \text{OK} } &\\
\end{flalign*}
\end{frame}

\section{Extending FIJ to intersection types}

\subsection{What are intersection types?}

\begin{frame}{What are intersection types?}
\boldmath
Let's suppose that we have two types $A$ and $B$.\\
The intersection type between these types is written like $A\&B$.\\
\end{frame}

\begin{frame}[fragile]{What are intersection types?}
\boldmath
A simple example of intersection types in pseudo-code.
\begin{flushleft}
\begin{lstlisting}[basicstyle=\scriptsize]
public interface A{
	public static final String name = "myName";
}

public interface B{
	public static final String surname = "mySurname";
}

public class C implements A,B{
}

C example = new(C());

print(example.name +" "+ example.surname);

//Print the String "myName mySurname"
\end{lstlisting}
\end{flushleft}
\end{frame}

\subsection{Why intersection types in Java?}
\begin{frame}{Why intersection types in Java?}
The need of intersection types was born to make possile the typing of constructs like \textbf{conditional expressions} and \textbf{var}.\\
Java need to create an intersection type to be able to statically check the correct type of these two things, Why?
\end{frame}

\begin{frame}
\frametitle{Conditional expressions problem}
Consider the conditional expression \boldmath{$c?a:b$}, where $a$ is of Type $A$ and $b$ is of Type $B$.\\
This expression say that if $c$ is true return $a$, otherwise return $b$.\\ The problem is that Java must evaluate the return type statically.

\begin{center}
\begin{tikzpicture}[scale = 2.1]
\node at (4,0) [rectangle,draw] (a100) {$Class\ A$};
\node at (6,0) [rectangle,draw] (b100) {$Class\ B$};
\node at (3,1) [rectangle,draw] (c100) {$Object$};
\node at (5,1) [rectangle,draw] (d100) {$Interface\ I$};
\node at (7,1) [rectangle,draw] (e100) {$Interface\ H$};
\draw[dashed, ->] (a100) -> (e100);
\draw[thick, ->] (a100) -> (c100);
\draw[thick, ->] (b100) -> (c100);
\draw[dashed, ->] (a100) -> (d100);
\draw[dashed, ->] (b100) -> (d100);
\draw[dashed, ->] (b100) -> (e100);
\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}
\frametitle{Conditional expressions problem}
\boldmath
To solve this problem Java introduces intersection types.\\
In this way we can consider the return type of the conditional expression as $I\&H$.\\
This can sound strange because the attitude of Java is to work with nominal types, but it was the only way.
\end{frame}

\begin{frame}[fragile]
\frametitle{Example}
\framesubtitle{Conditional expression and var}
\boldmath
\begin{flushleft}
	\begin{lstlisting}
	public interface TypeA {
	}
	
	public interface TypeB {
	}
	
	public class ClassA implements TypeB, TypeA{
	}
	
	public class ClassB implements TypeB, TypeA{
	}
	\end{lstlisting}
\end{flushleft}
\end{frame}

\begin{frame}[fragile]
\frametitle{Example}
\framesubtitle{Conditional expression and var}
\boldmath
\begin{flushleft}
	\begin{lstlisting}[basicstyle=\scriptsize]
	public class main {
	
		public static void main(String[] args) {
			double a = Math.random()*10;
			System.out.print(a);
	
			var v = m((h) -> h>5 ? new ClassA() : new ClassB(), a);
			v.getClass();
		}
	
		static <T> T m(Function<Double, T> a, Double b) {
			return a.apply(b);
		}
	
	}
	\end{lstlisting}
\end{flushleft}
\end{frame}

\begin{frame}[fragile]
\frametitle{Example}
\framesubtitle{Conditional expression and var}
\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{../../../../Documenti/varexample}
	\caption{}
	\label{fig:varexample}
\end{figure}

\end{frame}

\subsection{Extending the syntax}
\begin{frame}{The new syntax}
\begin{flalign*}
T &::= \hspace{206pt}\syntaxtag{type literal}&\\
&\qquad C \; | \; I \; | \; AndC \; | \; AndI &\\
AndC &::= \hspace{135pt}\syntaxtag{intersection type C\&I\&...\&I}&\\
&\qquad C \, \& \, AndI &\\
AndI &::= \hspace{149pt}\syntaxtag{intersection type I\&...\&I}&\\
&\qquad I\, \&\, AndI \; | \; I\\
\end{flalign*}
\end{frame}

\subsection{Extending the subtype relation}
\begin{frame}
\frametitle{Extending the definition of the subtype relation}

\begin{definition}
\vspace{-25pt}
\begin{flalign*}
&T<:T &\\[5pt]
&T\&T = T &\\[5pt]
&T\&U <: T &\\[5pt]
&T\&U <: U &\\[5pt]
&\dfrac{T<:U \qquad T<:V}{T<:U\&V} &\\
&T\longrightarrow U\&T\longrightarrow V<:T\longrightarrow(U\&V)
\end{flalign*}
\end{definition}
\end{frame}


\subsection{Auxiliary functions}

\begin{frame}{Preparing for extension}
% \framesubtitle{Adding some auxiliary functions}
\boldmath
We redefine $mtype$ and $mbody$ for groups of interfaces or groups made by class and interfces.
\end{frame}

\subsubsection{$\Omega in$ function}

\subsubsection{mtype function}
\begin{frame}
\frametitle{mtype function for $\aargs I$}
% \framesubtitle{For interfaces}
\begin{definition}
\vspace{-20pt}
\begin{flalign*}
&\dfrac{
U\ m(\aargs U\ \aargs x);\,\in\,\sig(\aargs I)
}{mtype(m, \aargs I)=\aargs U \rightarrow U}
\end{flalign*}
\end{definition}
\end{frame}

\subsubsection{mtype function}
\begin{frame}
\frametitle{mtype function for C\&$\aargs I$}
% \framesubtitle{For interfaces}
\begin{definition}
\vspace{-20pt}
\begin{flalign*}
&\dfrac{
U\ m(\aargs U\ \aargs x);\,\in\,\sig(C) \vee
U\ m(\aargs U\ \aargs x);\,\in\,\sig(\aargs I)
}{mtype(m,C\&\aargs I)=\aargs U \rightarrow U}
\end{flalign*}
\end{definition}
\end{frame}

\begin{frame}{$mbody$ function}
\begin{definition}
\vspace{-20pt}
\begin{flalign*}
&\dfrac{
\mathlarge{
CT(I) = \iclass{C}{D}{I} \atop
T\ m(\aargs T\ \aargs x)\; \{\syntaxkeyword{return }t;\}\,\in\aargs M
}
}{mbody(m,C) = (\aargs x, t)}&\\[10pt]
&\dfrac{
\mathlarge{
CT(C)=\iclass{C}{D}{I}
\atop m\text{ is not defined in }\aargs M
}
}{mbody(m,C) = mbody(m,D)}&
\end{flalign*}
\end{definition}
\scriptsize
\begin{alertblock}{Note}
\boldmath
The function does not  change after the introduction of intersection types, because we use it statically only with classes and, moreover, it does not make sense to invoke it on interfaces.
\end{alertblock}
\end{frame}

\subsection{Extending the typing rules}

\begin{frame}
\frametitle{The new typing rules}
\vspace{-30pt}
\begin{flalign*}
&&\syntaxtag{(T-VAR)} \\[-20pt]
&\dfrac{ x:T \in \Gamma }{ \Gamma \vdash x:T } &\\[10pt]
&&\syntaxtag{(T-FIELD)} \\[-20pt]
&\dfrac{ \Gamma \vdash t_0 : C_0 \qquad fields(C_0) = \aargs T \; \aargs f}
{\Gamma \vdash t_0 . f_i : T_i }&\\[10pt]
&&\syntaxtag{(T-UCAST)} \\[-20pt]
&\dfrac{ \Gamma \vdash t_0 : U \qquad U <: T}
{ \Gamma \vdash (T)\, t_0 : T} &\\[10pt]
&&\syntaxtag{(T-DCAST)} \\[-20pt]
&\dfrac{ \Gamma \vdash t_0:U \qquad T <: U \qquad T \neq U}
{ \Gamma \vdash (T)\, t_0:T}
\end{flalign*}
\end{frame}

\begin{frame}
\frametitle{The new typing rules}
\vspace{-30pt}
\begin{flalign*}
&&\syntaxtag{(T-INVK)} \\[-20pt]
&\dfrac{
\mathlarge{
\Gamma \vdash t_0:C_0 \qquad mtype(m, C_0) = \aargs U \rightarrow T
\atop
\Gamma \vdash \aargs t:\aargs T \qquad \aargs T <: \aargs U \hs
}
}{ \Gamma \vdash t_0.m(\aargs t): T \hs} &\\[10pt]
&&\syntaxtag{(T-NEW)} \\[-20pt]
&\dfrac{
\mathlarge{
fields(C) = \aargs U \ \aargs f \atop
\Gamma \vdash \aargs t:\aargs T \qquad \aargs T <: \aargs U \hs
}
}{\Gamma \vdash \syntaxkeyword{new }C(\aargs t):C \hs}&\\[10pt]
\end{flalign*}
\end{frame}

\begin{frame}
\frametitle{The new typing rules}
\vspace{-30pt}
\begin{flalign*}
&&\syntaxtag{(m OK in C)} \\[-20pt]
&\dfrac{
\mathlarge{
\aargs x: \aargs T, \syntaxkeyword{this}:C \vdash t_0:U \qquad U<:T
\atop {
% CT(C)=\iclass{C}{D}{I}
% \onto{
% \sig(C) = \Sigma \qquad is\sig ok(\Sigma)
T\ m(\aargs T\ \aargs x);\,\in\,\sig(C) \vee T\ m(\aargs T\ \aargs x);\,\in\,\sig(\aargs I)
% }
}
}
}{
T \  m(\aargs T \aargs x)\; \{ \syntaxkeyword{return } t_0;\}\ OK\ in\ C
}\\[20pt]
&&\syntaxtag{(C OK for $\aargs I$)} \\[-20pt]
&\dfrac{
\mathlarge{
T \; m(\aargs T \aargs x); \in \sig(\aargs I) \qquad mbody(m,C)=(\aargs x,t_0)
\atop
mtype(m, C) = \aargs T \rightarrow U \qquad U = T \hs
}
}{ C\ OK\ for\ \aargs I} \hspace{-300pt} &\\[20pt]
&&\syntaxtag{alternative (C OK for $\aargs I$)} \\[-20pt]
&\dfrac{
\sig(\aargs I) \subseteq \sig(C)
}{ C\text{ OK for }\aargs I} &\\
\end{flalign*}
\end{frame}

\begin{frame}
\frametitle{The new typing rules}
\begin{flalign*}
&&\syntaxtag{(C OK)} \\[-20pt]
&\dfrac{
\mathlarge{
K  =  C(\aargs U \ \aargs g, \aargs T \ \aargs f)\ \{\syntaxkeyword{super}(\aargs g ); \; \syntaxkeyword{this}.\aargs f = \aargs f;\}
\onto{
fields(D)=\aargs U\ \aargs g \qquad \aargs M \text{ OK IN } C \hs
\onto{
\Sigma=\sig(C)\cup\sig(\aargs I) \qquad is\sig ok(\Sigma) \qquad C \text{ OK FOR } \aargs I
}
}
}
}{\small{\iclass{C}{D}{I} \text{ OK}}}&\\[20pt]
% &&\syntaxtag{(m OK in I)}\\[-20pt]
% &\dfrac{
%   \mathlarge{
%     \small{CT(I) = \einterface{I}} \qquad J\in \aargs I \atop
%     override(m,J,\aargs T, T)
%   }
% }{T \ m(\aargs T \ \aargs x); \enspace \text{OK in } I } &\\[10pt]
&&\syntaxtag{(I OK)} \\[-20pt]
&\dfrac{\sig(I)=\Sigma \qquad is\sig ok(\Sigma)
% \qquad \aargs S \text{ OK in }I
}
{\einterface{I} \enspace \text{OK} } &\\
\end{flalign*}
\end{frame}

\begin{frame}{Typing rule for conditional expression}
There is only one rules:
    \begin{flalign*}
&\dfrac{\Gamma \vdash t_1 : boolean \quad \Gamma \vdash t_2 : T \quad \Gamma \vdash t_3 : T}
 {\Gamma \vdash if \quad t_1 \quad then \quad t_2 \quad else \quad t_3 : T } 
 \end{flalign*}

That means:
\begin{enumerate}
    \item $t_1$ must be of the type boolean.
    \item The types of $t_2$ and $t_3$ they must be of the same type.
\end{enumerate}
\end{frame}

\begin{frame}{Typing rule for conditional expression}
We need a syntax-driven rule for the conditional expressions, such that types are preserved under evaluation while common supertypes of the two branches are considered.\newline
Two alternatives:
\begin{enumerate}
    \item a restricted rule,
    \item join between the types.
\end{enumerate}
\end{frame}

\begin{frame}{Typing rule for conditional expression}
There is:
     \begin{flalign*}
&\dfrac{t_1 : Bool \quad t_2 : T_i \quad t_3 : T_j \quad T_i <: T_j}
 {if \quad t_1 \quad then \quad t_2 \quad else \quad t_3 : T_j} 
 \end{flalign*}
That has been firstly adopted by Java for typing the expression $t_1 ? t_2 : t_3$.
\end{frame}

\begin{frame}{Typing rule for conditional expression}
Typechecking expressions with multiple result branches, such as conditionals or case expressions, in a language with subtyping requires some additional machinery. For example, recall the declarative typing rule for conditionals. More spesific, we need a proposition.
\begin{enumerate}
    \item For every pair of types $S$ and $T$, there is some type $J$ such that $S \lor T = J$.
    \item For every pair of tyes $S$ and $T$ with a common supertype, there is some type $M$ such that $S \wedge	T = M$
\end{enumerate}
\end{frame}

\begin{frame}{Typing rule for conditional expression}
     There is:
     \begin{flalign*}
&\dfrac{\Gamma \vdash t_1 : T_1 \quad T_1=boolean \quad \Gamma \vdash t_2 : T_2 \quad \Gamma \vdash t_3 : T_3 \quad T_2 \lor T_3 = T}{\Gamma \vdash  if \quad t_1\quad then \quad t_2 \quad else \quad t_3 : T } 
\end{flalign*}
Where $T_2 \lor T_3 = T$ is the join of two types, which returns the minimum common supertype.\newline\newline
However the rule needs to prove, that there is always a join for any pair of types.\newline\newline
At the moment Java use this rules.
\end{frame}

\begin{frame}{Why we need interfaces? [1/2]}
    Interfaces are useful because they permit a richer, non-tree-structured, subtype relation: each class has a single superclass (from which it inherits instance variables and method bodies), but may additionally implement any number of interfaces.\newline\newline
    But, the presence of interfaces in Java actually forces the choice of an algorithmic presentation of the typing relation, which gives each typable term a unique (minimal) type. The reason is an interaction between conditional
expressions (written t1 ? t2 : t3 in Java) and interfaces.

\end{frame}

\begin{frame}{Why we need interfaces? [2/2]}
   
    Therefore: each class will have a single superclass from which it inherits the instances of the variables and the bodies of the methods, but it can also implement any number of interfaces.
\end{frame}
\begin{frame}
\frametitle{Interface in conditional expression [1/2]}
\framesubtitle{The problem}
In the presence of interfaces it is possible to have a more complex subtype relationship not constrained by the tree structure, the problem of understanding what is the minimum common supertype of two classes arises.\newline
\end{frame}

\begin{frame}{What does it mean specifically? [2/2]}
    \textit{"With interfaces it is no longer guaranteed that 2 types have the minimum supertype common, which can lead to problems for example on Java conditionals."}
\end{frame}
\begin{frame}{Interface in conditional expression}
    \underline{in FJ without interfaces}: this is trivial, since the minimum common supertype of two classes is the root of its minimal-length sub-tree that contains both.\newline\newline
    \underline{in FJ with interfaces}: requires the introduction of the join operation between types, which returns the minimum common supertype.\newline\newline
However in the presence of interfaces, the subtype relation is not necessarily
closed under joins. 
\end{frame}


\begin{frame}{Example 1}
Consider $I_0,I_1,I_2,I_3,I_4$ interfaces.\newline
The subtypes of $I_1$ are $I_1, I_3, I_4$ in order that the subtype relationship to be closed with respect to the join, it would be necessary that $join(I_3,I_4)$ had as a result a subtipe of $I_1$, but it is not so since it is $I_0$.
\begin{center}
\begin{tikzpicture}[scale = 1.7]
\node at (4.5,1.5)  (a0) {\LARGE
$I_0$};
\node at (4,0) (a3) {\LARGE
$I_3$};
\node at (4,1) (a1) {\LARGE
$I_1$};
\node at (5,1)  (a2) {\LARGE
$I_2$};
\node at (5,0)  (a4) {\LARGE
$I_4$};
\draw[thick, -] (a0) -> (a1);
\draw[thick, -] (a0) -> (a2);
\draw[thick, -] (a4) -> (a1);
\draw[thick, -] (a4) -> (a2);
\draw[thick, -] (a3) -> (a1);
\draw[thick, -] (a3) -> (a2);
\end{tikzpicture}
\end{center}
Figure: Example of a relationship between interfaces.
\end{frame}

\begin{frame}{Example 2}
Here the $join(I_3,I_4)$ it is not defined, since there is not  minimum common supertype.
\begin{center}
\begin{tikzpicture}[scale = 1.7]
\node at (4,0)  (a3) {\LARGE$I_3$};
\node at (4,1) (a1) {\LARGE$I_1$};
\node at (5,1)  (a2) {\LARGE$I_2$};
\node at (5,0)  (a4) {\LARGE$I_4$};
\draw[thick, -] (a4) -> (a1);
\draw[thick, -] (a4) -> (a2);
\draw[thick, -] (a3) -> (a1);
\draw[thick, -] (a3) -> (a2);
\end{tikzpicture}
\end{center}
Figure: Example of a relationship between interfaces.
\end{frame}

\begin{frame}{Frame Title}
\frametitle{The new typing rules}
Java solves the problem by assigning a join type statically to the conditional expression, basically it is the intersection of the minimums supertypes of the entities involved.\newline\newline 
Considering the Example 2. \newline\newline 
For Java the type of the conditional expression: $t_1 ? t_2 : t_3$ it would be the set of the interfaces $I_1$ and $I_2$.
\end{frame}

\begin{frame}
Insteand of the standard algorithm rule for conditional expression,

\begin{flalign*}
&\dfrac{\Gamma \vdash t_1 : boolean \quad \Gamma \vdash t_2 : E_2 \quad \Gamma \vdash t_3 : E_3 }{\Gamma \vdash t_1 ? t_2 : t_3 : E_2 \lor E_3 } 
\end{flalign*}
Java uses the following restricted rules:
\begin{flalign*}
&\dfrac{\Gamma \vdash t_1 : boolean \quad \Gamma \vdash t_2 : E_2 \quad \Gamma \vdash t_3 : E_3 \quad \Gamma \vdash E_2 <: E_3 }
 {\Gamma \vdash t_1 ? t_2 : t_3 : E_3 } 
 \end{flalign*}

\begin{flalign*}
&\dfrac{\Gamma \vdash t_1 : boolean \quad \Gamma \vdash t_2 : E_2 \quad \Gamma \vdash t_3 : E_3 \quad \Gamma \vdash E_3 <: E_2 }
 {\Gamma \vdash t_1 ? t_2 : t_3 : E_2 }
\end{flalign*}
These are intuitive sound, but they interact poorly with small-step style operational semantics used for FJ; the type preservativo property is actually false.
\end{frame}
\begin{frame}{Frame Title}

Definition: A type $J$ is called a \textit{join} of a pair of types $S$ and $T$, written $S OR
T = J$, if $S <: J$, $T <: J$, and, for all types $U$, if $S <: U$ and $T <: U$, then $J <: U$.
\end{frame}




\begin{frame}[fragile]{Normal case expression typing}
\boldmath
The body of the classes and interfaces.	\begin{flushleft}
\begin{lstlisting}[basicstyle=\scriptsize]
public interface I0 {
	public String method0();
}
public interface I1 {
	public String method1();
}
public class A extends Object implements I0 {
	public String method0() {return "A";}
}
public class B extends Object  implements I1 {
	public String method1() {return "B";}
}
\end{lstlisting}
\end{flushleft}

\end{frame}

\begin{frame}
\frametitle{Example 1}
\framesubtitle{Conditional expression problem}
\begin{figure}
\centering
\includegraphics[width=1\linewidth]{images/example-normal-type.png}
\caption{Java correctly assigns the type \texttt{Object}}
\label{fig:mainres}
\end{figure}
\end{frame}


\begin{frame}[fragile]{Conditional expression typing}
\boldmath
The body of the interfaces.	\begin{flushleft}
\begin{lstlisting}[basicstyle=\scriptsize]
public interface I0 {
	public String method0();
}
public interface I1 {
	public String method1();
}
public interface I2 extends I0, I1 {
	public String method();
	public String method2();
}
public interface I3 extends I0, I1 {
	public String method();
	public String method3();
}
\end{lstlisting}
\end{flushleft}
\end{frame}

\begin{frame}[fragile]{Conditional expression typing}
\boldmath
The body of the classes.	\begin{flushleft}
\begin{lstlisting}[basicstyle=\scriptsize]
public class A implements I2 {
	public String method0() {	return "A";	}
	public String method1() {	return "A";	}
	public String method() {	return "A";	}
	public String method2() {	return "A"; }
}

public class B implements I3 {
	public String method0() {	return "B";}
	public String method1() {	return "B";}
	public String method() {	return "B";}
	public String method3() {	return "B";}
}
\end{lstlisting}
\end{flushleft}

\end{frame}

\begin{frame}[fragile]{Conditional expression typing}
\boldmath
The body of the classes.	\begin{flushleft}
\begin{lstlisting}[basicstyle=\scriptsize]

public class Main {
	public static void main(String[] args) {
		(true ? new A() : new B()).method0();
		(false ? new A() : new B()).method1();
		(false ? new A() : new B()).m();
	}
}
\end{lstlisting}
\end{flushleft}
With this follow classes structure, the execution of the following program does not report static errors.
\end{frame}

\begin{frame}
\frametitle{Example 2}
\framesubtitle{Conditional expression problem}
\begin{figure}
\centering
\includegraphics[width=1\linewidth]{images/example-intersection-type.png}
\caption{The type that Java creates to assign a type to the conditional expression is \texttt{Object \& I0 \& I1}}.
\label{fig:mainres}
\end{figure}
\end{frame}
\begin{frame}{Frame Title}
    \textit{"The intersection type means having both one and the other specific of the interfaces involved, meaning that, that value is in the intersection of both, consequently with the conditional, if they don't have a minimum supertype common, I can pull it with this.."}
\end{frame}





\end{document}
